



## 题目

给你两个 没有重复元素 的数组nums1 和nums2，其中nums1是nums2的子集。

请你找出 nums1中每个元素在nums2中的下一个比其大的值。

nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。



示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
示例 2:

输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。


提示：

1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
nums1和nums2中所有整数 互不相同
nums1 中的所有整数同样出现在 nums2 中


进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-greater-element-i
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。











## 说明

### 方法一：自己乱写（暴力）
#### 思路


#### 算法



#### 复杂度分析




### 方法二：暴力解法（官网推荐）
#### 思路
题目中的关键信息：两个数组各自 没有重复元素。模拟题目的意思：对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。

#### 算法







#### 复杂度分析
- 时间复杂度：O(NM)，
  - 这里 NN 是数组 nums1 的长度， MM 是数组 nums2 的长度，对于 N 个 nums1 中的元素，最差情况下需要遍历完 nums2 中的每个元素，因此时间复杂度为 O(NM)；

- 空间复杂度：
  - 如果不计算保存结果的空间，空间复杂度为 O(1)；
  - 如果计算保存结果的空间，空间复杂度为 O(N)。

- 「暴力解法」时间复杂度高 ，空间复杂度低，优化「暴力解法」的思路是「空间换时间」。事实上，找右边第 1 个大于比自己大的数，这是一个典型的「栈」的应用（也叫「单调栈」），将每一个元素进栈一次、出栈一次，这样的过程中就可以找到找右边第 1 个大于比自己大的数。


### 方法三：栈（单调栈）（官网推荐）
#### 思路
根据题意，数组 nums1 视为询问。我们可以：

- 先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；
- 将上一步的对应关系放入哈希表（HashMap）中；
- 再遍历数组 nums1，根据哈希表找出答案。

下面我们解释如何得到 nums2 的每个元素右边第 1 个比它大的元素，这里以 nums2 = [2, 3, 5, 1, 0, 7, 3] 为例进行说明，我们从左到右遍历数组 nums2 中的元素。

友情提示：只需要看文字和图例的前几句话，找到解决问题的一帮规律，这样可以节约阅读时间。




归纳重点：

可以发现，我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] ... 执行同样的操作。

#### 算法





#### 复杂度分析

- 时间复杂度：O(N + M)，分别遍历数组 nums1 和数组 nums2 各一次即可，对于 nums2 中的每个元素，进栈一次，出栈一次；
- 空间复杂度：O(N)。我们在遍历 nums2 时，需要使用栈，以及哈希映射用来临时存储答案






























